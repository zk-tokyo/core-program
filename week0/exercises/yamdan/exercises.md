# 第0週事前課題回答
yamdan

## 演習1

### 1. 減算と除算の計算方法を調べ、それぞれ逆元に注目して説明してください

$a$ と $b$ の減算 $a - b$ は、
$a$ と $-b$ ($b$ の加法逆元) の加算、つまり $a + (-b)$ である。

$a$ と $b$ の除算は、
$a$ と $b^{-1}$ ($b$ の乗法逆元) の乗算、つまり $a \times b^{-1}$ である。

### 2. 拡張ユークリッド法について調べ、実装してください

拡張ユークリッド法は、
整数 $a$ と $b$ の最大公約数 $d$ を求めるユークリッド法を拡張したアルゴリズムで、
$d$ だけでなく
$a x + b y = d$ を満たす整数 $x$ と $y$ も同時に出力できるもの。

実装は Rust で行い、`./ext-euclid` ディレクトリに格納しました。
実装には AI の助けを借りました。

### 3. $3 - 2 \pmod{5}$ を計算してください

$1$

### 4. $3 \div 2 \pmod{5}$ を計算してください

$4$

($3 \div 2 \equiv 3 \times 2^{-1} \equiv 3 \times 3 \equiv 9 \equiv 4 \pmod{5}$)

### 5. $(7 \times 5)^{-1} \pmod{13}$ を計算してください

$3$

($(7 \times 5)^{-1} \equiv 35^{-1} \equiv 9^{-1} \equiv 3 \pmod{13}$)

## 演習2

### 1. $\mathbb{F}_2$ で $10110101 - 0110110$ を解いてください

$1$

$10110101_{2} \equiv 181_{10} \equiv 1 \pmod 2$ であり、
$0110110_{2} \equiv 54_{10} \equiv 0 \pmod 2$ なので、
$10110101_{2} - 0110110_{2} \equiv 1 \pmod 2$

(補足: $\mathbb{Z}$ であれば $10110101 - 0110110 = 1111111$)

### 2. $\mathbb{F}_{2^8}$ で $10110101 - 0110110$ を解いてください

$10000011$

$10110101$ を
$1 \alpha^7 + 0 \alpha^6 + 1 \alpha^5 + 1 \alpha^4 + 0 \alpha^3 + 1 \alpha^2 + 0 \alpha^1 + 1 \in \mathbb{F}_{2^8}$
とみなし、
$0110110$ を
$0 \alpha^6 + 1 \alpha^5 + 1 \alpha^4 + 0 \alpha^3 + 1 \alpha^2 + 1 \alpha^1 + 0 \in \mathbb{F}_{2^8}$
とみなすと、
それらの差は
$1 \alpha^7 + 0 \alpha^6 + 0 \alpha^5 + 0 \alpha^4 + 0 \alpha^3 + 0 \alpha^2 + 1 \alpha^1 + 1 \in \mathbb{F}_{2^8}$
となり、
これをベクトル表記すると $10000011$ となるため。

### 3. $\mathbb{F}_{2^3}$ における $x^3 + x + 1$ 以外の既約多項式を一つ見つけてください

$x^3 + x^2 + 1$

3 次多項式 $x^3 + a x^2 + b x + c$ が
$\mathbb{F}_{2^3}$ における既約多項式となるには
これが根をもたなければ良い。(3次多項式が分解されるなら必ず1次多項式を含むので)
つまり多項式に $x = 0, 1$ を代入して得られる
$c$ と $1 + a + b + c$ がいずれも $0$ でなければ良い。
前者から $c = 1$ であり、
すると後者から $1 + a + b + 1 \neq 0$ 、つまり $a + b = 1$ が成り立てば良いとわかる。
これを満たすのは $(a, b) = (1, 0)$ と $(a, b) = (0, 1)$ のみであり、
結果 $x^3 + x^2 + 1$ と $x^3 + x + 1$ の二つが既約多項式といえる。

## 演習3

### 1. 離散対数問題以外で安全性仮定になっている数学的問題を 2 つ挙げてください。それぞれ、なぜ安全と言えるのか説明してください

素因数分解問題と最短ベクトル問題。
素因数分解問題については、古典的な計算機を使って多項式時間で解く方法は見つかっていない。(量子計算機を使うと可能)
最短ベクトル問題については、古典的にも量子的にも効率的なアルゴリズムは見つかっていない。

### 2. 離散対数問題を効率的に解くアルゴリズムを一つ調べ、なぜ効率的か説明してください

シンプルなアルゴリズム Baby-Step Giant-Step 法について説明する。

$y = g^x \bmod p$ の $x$ を求めたい。

$m = \lceil\sqrt{p - 1}\rceil$ とする。

準備として、
$j = 0, 1, \ldots, m - 1$ に対して $g^j$ を計算し、
$(g^j, j)$ をハッシュマップ[^1]に保存する。これが Baby step。

[^1]: $O(1)$ 時間で探索できる辞書型のデータ構造であれば何でも良い

次に $i = 0, 1, \ldots, m - 1$ に対して $y \cdot g^{-i m}$ を計算していき、
これをキーとしてハッシュマップを検索する。これが Giant step。

もし Giant step のステップ $i$ でキー $g^{-i m}$ がヒットし、
ハッシュマップから値 $j$ が得られたら、
$i m + j$ が求める離散対数 $x$ である。
(ハッシュマップのヒット時には $y g^{-i m} = g^j$ が成立し、
$y = g^{i m + j}$ となるため)

Baby step でのマップ作成には $O(m)$ 時間かかる。
Giant step では各ステップでの検索がハッシュマップを使えば $O(1)$ 時間ででき、
これが最大 $m$ ステップあるので Giant step 全体で $O(m)$ 時間を要する。
結果、全体の時間計算量は $O(m) = O(\sqrt{n})$ 時間となる。
ハッシュマップのための空間計算量 $O(\sqrt{n})$ を要するものの、時間計算量 $O(\sqrt{n})$ は総当たり探索の $O(n)$ よりも効率が良い。

### 3. $5^x \equiv 8 \pmod{23}$ の離散対数 $x$ を求めてください

せっかくなので上で調べた Baby-Step Giant-Step 法で求めてみる。

$m = \lceil 23 - 1 \rceil = 5$ なので、
Baby step では以下のようなサイズ $5$ のハッシュマップを構築する:

| key        | value |
|------------|-------|
| $5^0 = 1$  |   $0$ |
| $5^1 = 5$  |   $1$ |
| $5^2 = 2$  |   $2$ |
| $5^3 = 10$ |   $3$ |
| $5^4 = 4$  |   $4$ |

次に Giant step を実施する。
各ステップでは $y g^{-i m} = 8 \cdot 5^{-5i}$ を計算し、これを上のハッシュマップで検索する。

- $i = 0$ の時、キーは $8 \cdot 5^0 = 8$。これはハッシュマップに存在しない。
- $i = 1$ の時、キーは $8 \cdot 5^{-5} = 8 \cdot 20^{-1} = 8 \cdot (-8) = 5$。これはハッシュマップに存在し、その値は $j = 1$ である。

したがって $i m + j = 1 \cdot 5 + 1 = 6$ が求める離散対数となる。
実際に $5^6 \equiv 8 \pmod{23}$ である。

## 演習4

### 1. ECDLPを効率的に計算するアルゴリズムをひとつ挙げてください

Pollard's Rho法 (ECDLPに限らず一般のDLPに対する効率的なアルゴリズム)

ECDLP は、楕円曲線上の 2 点 $P, Q$ が与えられたときに
$Q = x P$ となる $x$ を求める問題。

Pollard's Rho 法は
乱数列 $\{a_i\}, \{b_i\}$ を使って
$a_i P + b_i Q$
と
$a_{2i} P + b_{2i} Q$
を生成し、
もし
$a_i P + b_i Q = a_{2i} P + b_{2i} Q$
なる衝突が見つかったなら
$Q = \frac{a_i - a_{2i}}{b_{2i} - b_i} P$
であるから、
$x = (a_i - a_{2i}) / (b_{2i} - b_i)$
を解として出力するというアルゴリズム。

Birthday Bound によりこのような衝突は平均時間 $O(\sqrt{n})$ で見つけられるので、総当たり探索よりも効率的。

衝突の検出は常に インデックス $i$ と $2i$ の間で行われ、過去の履歴を保持しないので空間計算量は $O(1)$ で済む。
(Baby-step Giant-step 法は $O(\sqrt{n})$ 必要だった)

ただし確率的なアルゴリズムであり、
$O(\sqrt{n})$ はあくまで平均計算量であり、
場合によっては $O(n)$ かかることもあることに注意が必要。

### 2. スカラー倍算を効率的に計算するアルゴリズムをひとつ挙げてください

Double-and-Add 法

まずスカラー $n$ を2進数に展開して
ビット列
$b_k b_{k-1} \cdots b_0$ を得る。
($k = \lceil \log (n + 1) \rceil$, $\forall i.\ b_i \in \{0, 1\}$)

すると
$n = 2^k b_k + 2^{k-1} b_{k-1} + \cdots + b_0 = 2 ( 2 \cdots 2 (2 b_k + b_{k-1}) + b_{k-2}) + \cdots + b_0$
と書けるので、スカラー倍 $nP$ は
$nP = 2 ( 2 \cdots 2 (2 b_k P + b_{k-1} P) + b_{k-2} P) + \cdots + b_0 P$
と展開できる。
これを利用して、スカラー倍算は以下のように高々 $\log n$ 回の2倍(Double)と加算(Add)で計算できる。

1. $P$ を 2 倍する。( $2 b_k P = 2 P$ )
2. $b_{k-1}$ が $1$ だったら上の結果に P を加算する。( $2 b_k P + b_{k-1} P$ )
3. 上の結果を 2 倍する。 ( $2 (2 b_k P + b_{k-1} P)$ )
4. $b_{k-2}$ が $1$ だったら上の結果に P を加算する。( $2 (2 b_k P + b_{k-1} P) + b_{k-2} P$ )
5. (最下位ビットまで繰り返す)
6. $b_0$ が $1$ だったら上の結果に P を加算する。( $2 ( 2 \cdots 2 (2 b_k P + b_{k-1} P) + b_{k-2} P) + \cdots + b_0 P = nP$ )
7. 結果を $nP$ として出力する。

### 3. ゼロ知識証明ライブラリ「Circom」で使われているデフォルトの楕円曲線を調べてください

Circom の公式ドキュメント
[Complete compilation options - Circom 2 Documentation](https://docs.circom.io/getting-started/compilation-options/) には

>     -p, --prime <prime>    To choose the prime number to use to generate the circuit. Receives the
>                            name of the curve (bn128, bls12377, bls12381, goldilocks, grumpkin, pallas, secq256r1, vesta) [default: bn128]

とあり、bn128 曲線が circom のデフォルトで使われていることがわかる。

bn128 曲線は、
[BN254 For The Rest Of Us - HackMD](https://hackmd.io/@jpw/bn254) によれば
BN254 や `alt_bn_128` とも呼ばれる楕円曲線で、
$\mathbb{F}_p$ 上の曲線 $y^2 = x^3 + 3$ として定義される。
ここで $p$ は 254 ビットの素数であり、具体的には
$p = 21888242871839275222246405745257275088696311157297823662689037894645226208583$
と定められている。

### 4. BLS12-381上の2点 P(3, 5), Q(5, 3) の加算を[シュミレータ](https://andrea.corbellini.name/ecc/interactive/modk-mul.html)を使って計算してください

BLS12-381曲線は、
[BLS12-381 For The Rest Of Us - HackMD](https://hackmd.io/@benjaminion/bls12-381) によれば
$\mathbb{F}_q$ 上の曲線 $y^2 = x^3 + 4$ として定義される。
ここで $q$ は 381 ビットの素数であり、具体的には
$q = 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787$
(`0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab`)
と定められている。

実際に上の $q$ をセットするとシミュレータの処理が完了しなかったので、本課題はスキップします。
