# week 3 事前課題

yamdan

## 1. SNARK とは … ARgument of Knowledge（p.7）を指しますが、なぜ「証明」であるのに “argument” と表現しているのでしょうか？ ”proof” と “argument” の違いを調べて説明してみましょう。

知識の証明が満たすべき要件の一つである「知識の健全性(knowledge soundness)」が、
どんな攻撃者でも無条件に成り立つなら proof of knowledge と呼ばれるが、
何らかの計算量的仮定の下でのみ成り立つときには argument of knowledge と呼ばれる。

Proof of knowledgeは、無限の計算能力を持つ攻撃者であっても、
自分のもたない知識を知っているふりをすることはできない。
Argument of knowledgeでは無限の計算能力を持つ攻撃者であれば
自分のもたない知識を知っているふりをして不正な証明を通すことができてしまう。
が、計算能力に限りのある攻撃者であって、計算量的仮定が成り立つ場面では健全性が守られる。

SNARKとして知られる方式の健全性は、
いずれも計算量的な仮定をおいて初めて証明ができるので
Argument of knowledgeに分類される。
例えばPinocchioの健全性はKnowledge of Exponent(KoE)仮定を必要とし、
Groth16の健全性はGeneric Group Model(GGM)の下でのみ証明される。
また、Plonkの健全性にはKZGコミットメントの知識健全性が必要とされ、それはKoE仮定またはGGMの下で成り立つ。

## 2. p.21のKZGにおいて、コミットメントに秘匿性（i.e., ゼロ知識性）を与えるにはどうすれば良いでしょうか？具体的な構築方法を調べて説明してみましょう。

[KZG Polynomial Commitments | ZKDocs](https://www.zkdocs.com/docs/zkdocs/commitments/kzg_polynomial_commitment/) によると、
大きく分けて2つの方法が存在する。

(1) コミット対象の多項式を評価点からの補間で作る場合: 補間前に一つ余計にランダムな評価点を追加することで、多項式をランダマイズし、結果コミットメントに秘匿性が備わる(コミットされた多項式の情報が秘匿される)。元々のドメインでの評価点は変わらないのでプロトコルの完全性に影響はしない。

(2) Pedersenコミットメントのように、乱数成分を含む要素を掛け合わせる。具体的には、 $g_1$ とは別の生成元 $h_1$ とランダム多項式 $\hat{f}$ を生成し、コミットメントを $Com_f \gets f(\tau) \cdot g_1 + \hat{f}(\tau) \cdot h_1$ として得る。ランダム多項式が加わるので元の多項式の情報がマスクされる。 $h_1$ は $g_1$ と独立に選択しないとコミットメントの束縛性(binding)が崩れるので注意。

## 3. f(a, b) = 5 * (a * b - a) + 2 * b を PLONK が適用できる形（i.e., 複数の一変量多項式）に途中経過をわかりやすく明示しながら変換してみましょう。

証明したい関数: $f(a, b) = 5 (ab - a) + 2b$

以下の5つのゲートからなる算術回路として表現する[^1]。

[^1]: $f$ を整理すると $f(a, b) = 5ab -5a + 2b$ となるのでゲート制約は1つだけでも良さそう

- ゲート0: $o_0 = a \times b$
- ゲート1: $o_1 = o_0 - a$
- ゲート2: $o_2 = 5 \times o_1$
- ゲート3: $o_3 = 2 \times b$
- ゲート4: $o_4 = o_2 + o_3$

これらをゲート制約式
$Q_L(x) L(x) + Q_R(x) R(x) + Q_M(x) L(x) R(x) + Q_O(x) O(x) + Q_C(x) = 0$
に当てはめると

| $x$ | $Q_L(x)$ | $Q_R(x)$ | $Q_M(x)$ | $Q_O(x)$ | $Q_C(x)$ |
|-|-|-|-|-|-|
| $\omega^0$ | 0 | 0 | 1 | -1 | 0 |
| $\omega^1$ | 1 | -1 | 0 | -1 | 0 | 
| $\omega^2$ | 5 | 0 | 0 | -1 | 0 |
| $\omega^3$ | 2 | 0 | 0 | -1 | 0 |
| $\omega^4$ | 1 | 1 | 0 | -1 | 0 |

であり、
列ごとに評価点を補間することで
セレクター多項式 $Q_L, Q_R, Q_M, Q_O, Q_C$ が得られる。

インプットとアウトプットに関しては、
入力を $a = 2, b = 3$ とすると以下のようなトレースが得られる。

- ゲート0: $o_0 = a \times b = 2 \times 3 = 6$
- ゲート1: $o_1 = o_0 - a = 6 - 2 = 4$
- ゲート2: $o_2 = 5 \times o_1 = 5 \times 4 = 20$
- ゲート3: $o_3 = 2 \times b = 2 \times 3 = 6$
- ゲート4: $o_4 = o_2 + o_3 = 20 + 6 = 26$

したがって

| $x$ | $L(x)$ | $R(x)$ | $O(x)$ |
|-|-|-|-|
| $\omega^0$ | 2 | 3 | 6 |
| $\omega^1$ | 6 | 2 | 4 |
| $\omega^2$ | 5 | 4 | 20 |
| $\omega^3$ | 2 | 3 | 6 |
| $\omega^4$ | 20 | 6 | 26 |

であり、列ごとに評価点を補間することでウィットネス多項式 $L, R, O$ が得られる。

ここで

- $a$: ゲート0の左入力 = ゲート1の右入力
- $b$: ゲート0の右入力 = ゲート3の右入力
- $o_0$: ゲート0の出力 = ゲート1の左入力
- $o_1$: ゲート1の出力 = ゲート2の右入力
- $o_2$: ゲート2の出力 = ゲート4の左入力
- $o_3$: ゲート3の出力 = ゲート4の右入力

という関係にあることから、

| $x$ | $\sigma_L(x)$ | $\sigma_R(x)$ | $\sigma_O(x)$ |
|-|-|-|-|
| $\omega^0$ | $\omega^1 k_1$ | $\omega^3 k_1$ | $\omega^1 k_0$ |
| $\omega^1$ | $\omega^0 k_2$ | $\omega^0 k_0$ | $\omega^2 k_1$ |
| $\omega^2$ | $\omega^2 k_0$ | $\omega^1 k_2$ | $\omega^4 k_0$ |
| $\omega^3$ | $\omega^3 k_0$ | $\omega^0 k_1$ | $\omega^4 k_1$ |
| $\omega^4$ | $\omega^2 k_2$ | $\omega^3 k_2$ | $\omega^4 k_2$ |

となり、
列ごとに評価点を補間することでワイヤリング多項式 $\sigma_L, \sigma_R, \sigma_O$ が得られる。

## 4. p.52におけるパブリックインプット・アウトプットの証明をたった1つのKZG評価証明で行うにはどうすれば良いか、調べて説明してみましょう。→ ヒント: ゼロテスト（p.53~p.54）を用いる。

### $1$ 多項式 $1$ 評価 (基本形)

基本的なKZGコミットメントの評価証明では、1つの多項式を1つの点で評価した結果を証明する。

証明者は1つの多項式 $f$ のコミットメント
$Com_f := g_1^{f(\tau)}$ を計算し、
検証者へ送っているものとする。

ここで証明者は、
コミットされた多項式 $f$ が
点 $a$ で値 $b$ を取ることを証明したいものとする。

そのために証明者はまず
多項式 $f(x)$ を $x - a$ で割り、
商多項式 $q(x)$
と剰余 $r$ を得る。
このとき $f(x) = q(x)(x-a) + r$ である。

ここで $f(a) = b$ であるから
$r = b$ となる。

そして $q$ のコミットメント
$Com_q := g_1^{q(\tau)}$ を計算し、検証者へ送る。

検証者は以下の式が成り立つことを確認できたら、証明者の主張を受け入れる。
$$e(Com_f / g_1^{b}, g_2) = e(Com_q, g_2^{\tau - a})$$

(完全性)
証明者がプロトコルに従っていれば (上のように $Com_f$, $Com_q$ が作られていたら)、
この検証式は
$$f(\tau) - b = q(\tau)(\tau-a)$$
と等価であり、
$q$ の定義から必ず真となる。

### $1$ 多項式 $m$ 評価

基本形と同様、
証明者は多項式 $f$ のコミットメント
$Com_f := g_1^{f(\tau)}$ を
検証者へ送っているものとする。

しかし先ほどと異なり、ここで証明者が示したいことは、
多項式 $f$ が複数の点 $a_i$ ($i \in [1, m]$) で
それぞれ値 $b_i$ を取ることであるとする。

基本形を複数回繰り返せば実現できるが、
その場合、計算量も通信量も評価点の個数 $m$ に比例してしまう。
より効率的なバッチ計算の方法がKZG10論文で示されている。

証明者はまず
多項式 $f(x)$ を $(x - a_1) \cdots (x - a_m)$ で割り、
商多項式 $q(x)$ と剰余多項式 $r(x)$ を得る。
このとき $f(x) = q(x) (x-a_1) \cdots (x-a_m) + r(x)$ である。

ここで $f(a_i) = b_i$ であるから
$r(a_i) = b_i$ となる。

そしてそれらのコミットメント
$Com_q := g_1^{q(\tau)}$
と
$Com_r := g_1^{r(\tau)}$
を計算し、検証者へ送る。

検証者は以下の式が成り立つことを確認する。
$$e(Com_f / Com_r, g_2) = e(Com_q, g_2^{(\tau - a_1) \cdots (\tau - a_m)})$$

(完全性)
証明者がプロトコルに従っていれば (上のように $Com_f$, $Com_q$, $Com_r$ が作られていたら)、
この検証式は
$$f(\tau) - r(\tau) = q(\tau) (\tau - a_1) \cdots (\tau - a_m)$$
と等価であり、
$q, r$ の定義から必ず真となる。

### $l$ 多項式 $1$ 評価

証明者は $l$ 個の多項式 $f_i$ ($i \in [1, l]$)
をコミットして得られた
$l$ 個のコミットメント
$Com_{f_i} := g_1^{f_i(\tau)}$ ($i \in [1, l]$) を
検証者へ送っているものとする。

ここで証明者が示したいことは、
複数の多項式 $f_i$ ($i \in [1, l]$) が
1つの点 $a$ でそれぞれ値 $b_i$ を取ることであるとする。

こちらも基本形を複数回繰り返せば実現できるが、
その場合、計算量も通信量も多項式の個数 $l$ に比例してしまう。
より効率的なバッチ計算の方法がPlonkの論文で示されている。

ここでは検証者が乱数 $\gamma \in \mathbb{F}$ を選び、
証明者へ送るところから始まる。

証明者はまず
多項式 $f_i(x)$ を $x - a$ で割り、
商多項式 $q_i(x)$
と剰余 $r_i$ を得る。
このとき $f_i(x) = q_i(x) (x-a) + r_i$ である。

ここで $f_i(a) = b_i$ であるから
$r_i = b_i$ となる。

得られた複数の商多項式をそれぞれコミットして送ると
通信量が $l$ に比例してしまうので、ここでは
検証者から受け取った乱数 $\gamma$ を用いて
これらを以下のように1つの多項式にまとめる。

$$q(x) = q_1(x) + \gamma q_2(x) + \ldots + \gamma^{l-1} q_l(x)$$

その上で、コミットメント
$Com_{q} := g_1^{q(\tau)}$
を検証者へ送る。

検証者は以下の式が成り立つことを確認できたら、証明者の主張を受け入れる。
$$e(\prod_i (Com_{f_i} / g_1^{b_i})^{\gamma^{i-1}}, g_2) = e(Com_q, g_2^{\tau - a})$$

(完全性)
証明者がプロトコルに従っていれば (上のように $Com_{f_i}$, $Com_q$ が作られていたら)、
この検証式は
$i \in [1, l]$ について
$$\gamma^{i - 1}(f_i(\tau) - b_i) = \gamma^{i - 1} q_i(\tau)(\tau-a)$$
と等価であり、
$q_i$ の定義から必ず真となる。

### $l$ 多項式 $m$ 評価

上に示した
$1$ 多項式 $m$ 評価の方法と
$l$ 多項式 $1$ 評価の方法を
組み合わせることで実現できる。

証明者は $l$ 個の多項式 $f_i$ ($i \in [1, l]$)
をコミットして得られた
$l$ 個のコミットメント
$Com_{f_i} := g_1^{f_i(\tau)}$ ($i \in [1, l]$) を
検証者へ送っているものとする。

ここで証明者が示したいことは、
複数の多項式 $f_i$ ($i \in [1, l]$) が
複数の点 $a_j$ ($j \in [1, m]$) で
それぞれ値 $b_{i, j}$ を取ることであるとする。
($f_i(a_j) = b_{i,j}$)

ここでは検証者が乱数 $\gamma \in \mathbb{F}$ を選び、
証明者へ送るところから始まる。

証明者はまず
多項式 $f_i(x)$ を $(x - a_1) \cdots (x - a_m)$ で割り、
商多項式 $q_i(x)$
と剰余多項式 $r_i(x)$ を得る。
このとき $f_i(x) = q_i(x) (x-a_1) \cdots (x-a_m) + r_i(x)$ である。

ここで $f_i(a_j) = b_{i,j}$ であるから
$r_i(a_j) = b_{i,j}$ となる。

得られた複数の多項式をそれぞれコミットして送ると
通信量が $l$ に比例してしまうので、ここでは
検証者から受け取った乱数 $\gamma$ を用いて
これらを以下のように1つの多項式にまとめる。

$$q(x) = q_1(x) + \gamma q_2(x) + \ldots + \gamma^{l-1} q_l(x)$$

$$r(x) = r_1(x) + \gamma r_2(x) + \ldots + \gamma^{l-1} r_l(x)$$

その上で、コミットメント
$Com_q := g_1^{q(\tau)}$
と
$Com_r := g_1^{r(\tau)}$
を検証者へ送る。

検証者は以下の式が成り立つことを確認できたら、証明者の主張を受け入れる。
$$e(\prod_i Com_{f_i}^{\gamma^{i-1}} / Com_{r}, g_2) = e(Com_q, g_2^{(\tau - a_1) \cdots (\tau - a_m)})$$

(完全性)
証明者がプロトコルに従っていれば (上のように $Com_{f_i}$, $Com_q$, $Com_r$ が作られていたら)、
この検証式は
$i \in [1, l]$ について
$$\gamma^{i - 1}(f_i(\tau) - r_i(\tau)) = \gamma^{i - 1} q_i(\tau)(\tau-a_1)\cdots(\tau-a_m)$$
と等価であり、
$q_i$, $r_i$ の定義から必ず真となる。
