## 1 STARKにおいては、多項式に関する低次元テスト（LDT, p.39）が必要ですが、これまでみてきたSNARKでは不要でした。なぜSTARKではLDTが必要で、Groth16とPLONKではそれぞれ不要なのかを数式をまじえて説明してみましょう。
STARKでは、Reed-Solomon符号を用いて評価点を増やすことで、一部の評価点の検証によって、証明者が正しい多項式を持っていることを確率的に検証することができるようになっている。
これは、ある多項式に対して、それとは異なるk次の多項式があったとき、その二つの交点は高々k個しかないことを利用している。
攻撃者が持っている偽の多項式がk次だったとして、評価点がN(>k)個のとき、検証者から送られてくるクエリに対して、攻撃者が正しい評価点を返せる確率の最大値は、攻撃者の多項式と正しい多項式の交点が評価点になっている時がで、k/Nである。
そのため、kに対してNを十分に大きくとれば、攻撃者がたまたま正しい評価点を返す確率は十分小さくなるため、検証者はNのうちの数点を確認するだけで、証明者が持っている多項式の正しさを確認できる。
ただし、このとき、攻撃者がN次の多項式を用意して検証を突破することを防ぐために、証明者の多項式が一定より小さいかどうかのテストする必要がある。
そのため、STARKではLDTが必要となる。  
一方で、Groth16やPLONKでは、多項式に対するそのような制約はないため、LDTは不要である。（数式的な部分の説明は時間的余裕が足りませんでした…）



---
## 2 スライドで説明されている構築方法では、STARKにゼロ知識性が付与されていません。STARKをzkSTARKに変換する方法を1つ取り上げ、なぜその方法がゼロ知識性を付与するのかを数式ベースで説明してみましょう。
STARKの元々の論文を参照すると、zkSTARKは、perfect zero-knowledgeを持つzkSTIKの実装であり、ランダムオラクルを衝突耐性ハッシュ関数で代用することで、computational-zeroknowledgeを持つとされている。
zkSTARKの具体的な構成方法を見てみると、スライドで紹介されていないモジュールとして、Algebraic Placement and Routing(APR)とAlgebraic Linking IOP(ALI)がある。
元々の論文内でのzkSTARKの構成は以下のようになっている。
1. AIR 証明したい計算の制約の代数的表現 
2. APR アフィングラフとreed-solomon符号を用いた、代数的な制約の最適化 
3. ALI 制約を単一のランダムな線型結合にリンク
4. FRI ALIによって変換された問題を解決
このうち、APRにおいて、ランダム性を導入することによって、ゼロ知識性が導入される。もう少し具体的に言えば、AIRでのwitnessに対して、ランダムな多項式をサンプリングしてAPRのwitnessとすることで、攻撃者はAPRのwitnessを見てもAIRのwitnessを知ることができないようにする。

[参考]
- https://eprint.iacr.org/2018/046.pdf#page=30.08

---
## 3 zkSNARK・zkSTARK（ゼロ知識性のないSNARK・STARKはNG）が利用されている具体的なプロトコル・サービスを一つ取り上げ、以下の項目に沿って分かりやすく説明してみましょう（公式ドキュメント等に記載がなければ推測しましょう）。
### a プロトコル・サービスの目的と大まかな仕組み
### b aにおいて、誰が誰に対して何に関する証明を生成しているのかとそれをゼロ知識証明で行う必要性
### c 利用しているゼロ知識証明種別（i.e., zkS{N||T}ARK）と具体的なプロトコル（e.g., Groth16）、その採択背景・理由
### d cに関する特筆すべき最適化手法の詳細（数式レベルで解説）
当日の発表資料参照

---