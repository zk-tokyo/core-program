## 1. STARKにおいては、多項式に関する低次元テスト（LDT, p.39）が必要ですが、これまでみてきたSNARKでは不要でした。なぜSTARKではLDTが必要で、Groth16とPLONKではそれぞれ不要なのかを数式をまじえて説明してみましょう。

### STARKの場合
STARKでは多項式の評価結果を大きな表として提示し、それをマークル木でコミットする。  
しかし、この表が「本当に低次数多項式から得られたものか」は直接は分からない。  

そのため **低次数テスト（LDT, FRI）** を行い、  
表全体が「低次数多項式に近い形」をしているかどうかを確認する必要がある。  
これにより、与えられたデータが“多項式らしい”ことを保証するのである。

---

### Groth16／PLONKの場合
Groth16やPLONKでは **SRSに基づく多項式コミットメント** を用いる。  
ここでは、コミットできる多項式の次数が最初から制限されており、  
証明者はその範囲を超えた多項式を提示することができない。  

そのため「低次数性」は構造的に強制されており、  
追加で表全体を検査するLDTは不要となる。  
検証者はランダムに選んだ一点で等式が成立しているかを確認するだけで十分である。

---

## 2. スライドで説明されている構築方法では、STARKにゼロ知識性が付与されていません。STARKをzkSTARKに変換する方法を1つ取り上げ、なぜその方法がゼロ知識性を付与するのかを数式ベースで説明してみましょう。

代表的な方法に、消失多項式を利用したブラインディングがある。
具体的には、各トレース多項式に対して、トレース領域や境界点でゼロとなる消失多項式を用い、ランダムな多項式を掛け合わせて加える操作を行う。消失多項式は特定の点で必ずゼロになるため、トレース領域や境界点では値が変わらず完全性は保たれる。一方で、それ以外の点ではランダムな成分が加わることで評価値が不規則になり、元の情報は検証者に漏れない。
さらに、この操作は AIR の制約多項式に組み込まれても整除性を損なわないため、低次数性の検証や一貫性チェックはそのまま有効である。つまり、計算が正しいことは従来通り確認できるが、計算の中身は乱数化によって秘匿される。この仕組みにより STARK にゼロ知識性が付与され、zkSTARK が実現される。